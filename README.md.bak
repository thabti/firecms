# FireCMS

A modern, headless CMS built with Next.js 16, Tailwind CSS, and shadcn/ui with pluggable storage backends.

## Quick Start

```bash
# Clone and install
git clone https://github.com/sabeurthabti/firecms.git
cd firecms
pnpm install

# Configure storage (uncomment SQLite in .env.local)
cp .env.local.example .env.local
# Edit .env.local and uncomment the SQLite section

# Run
pnpm dev
```

Open [http://localhost:3000/admin](http://localhost:3000/admin) to start creating content!

**Or use this one-liner for SQLite:**

```bash
git clone https://github.com/sabeurthabti/firecms.git && cd firecms && pnpm install && echo -e "STORAGE_TYPE=sqlite\nDATA_DIR=./data" > .env.local && pnpm dev
```

## Features

- **Modern Stack**: Next.js 16 with App Router, React 19, TypeScript
- **Pluggable Storage**: Choose from PostgreSQL (Neon), SQLite, or JSON file storage
- **PostgreSQL Support**: Production-ready with Neon serverless Postgres
- **SQLite Support**: Fast, local database for development and simple deployments
- **File Storage**: JSON-based storage for quick setup and portability
- **Image Optimization**: Automatic compression, multiple sizes, local file storage
- **Block-Based Content**: Flexible page builder with multiple block types
- **RESTful API**: Full API for headless CMS capabilities
- **Beautiful UI**: Tailwind CSS with shadcn/ui components
- **Type Safety**: Full TypeScript support throughout

## Block Types

- **Text**: Rich text content blocks
- **Heading**: H1-H6 headings with customizable levels
- **Image**: Image uploads with captions and alt text
- **List**: Ordered or unordered lists
- **Quote**: Blockquotes with optional author attribution

## Project Structure

```
firecms/
├── src/
│   ├── app/
│   │   ├── (public)/          # Public-facing pages
│   │   │   └── [slug]/        # Dynamic page routes
│   │   ├── admin/             # CMS admin panel
│   │   │   └── pages/         # Page management
│   │   ├── api/               # API routes
│   │   │   ├── pages/         # Pages CRUD
│   │   │   └── upload/        # Image upload
│   │   ├── layout.tsx         # Root layout
│   │   ├── page.tsx           # Home page
│   │   └── globals.css        # Global styles
│   ├── components/
│   │   ├── ui/                # shadcn/ui components
│   │   └── block-editor.tsx   # Block editor component
│   ├── lib/
│   │   ├── adapters/          # Storage adapters
│   │   │   ├── index.ts       # Adapter factory
│   │   │   ├── firebase-adapter.ts   # Firebase implementation
│   │   │   ├── postgres-adapter.ts   # PostgreSQL implementation
│   │   │   ├── sqlite-adapter.ts     # SQLite implementation
│   │   │   ├── json-adapter.ts       # JSON file implementation
│   │   │   ├── postgres/      # PostgreSQL utilities
│   │   │   │   ├── schema.ts
│   │   │   │   └── serializers.ts
│   │   │   └── sqlite/        # SQLite utilities
│   │   │       ├── schema.ts
│   │   │       └── serializers.ts
│   │   ├── api-utils.ts       # API versioning & responses
│   │   ├── db.ts              # Legacy Firestore (deprecated)
│   │   ├── firebase.ts        # Firebase config
│   │   └── utils.ts           # Utility functions
│   └── types/
│       ├── index.ts           # Core types
│       └── storage.ts         # Storage adapter interface
├── data/                      # Local storage (git-ignored)
│   ├── cms.db                 # SQLite database
│   └── cms-data.json          # JSON storage
├── STORAGE.md                 # Storage documentation
├── IMAGE_OPTIMIZATION.md      # Image optimization guide
├── package.json
├── tsconfig.json
├── tailwind.config.ts
└── next.config.ts
```

## Getting Started

### Prerequisites

- Node.js 18+
- pnpm (recommended) or npm
- Firebase project

### Installation

1. **Clone the repository**

```bash
git clone https://github.com/sabeurthabti/firecms.git
cd firecms
```

2. **Install dependencies**

```bash
pnpm install
```

3. **Choose and configure your storage backend**

FireCMS supports four storage options. Copy the example file and choose one:

```bash
cp .env.local.example .env.local
```

Then uncomment one of the storage options in `.env.local`:

### Option A: PostgreSQL/Neon (Recommended for Production)

Perfect for scalable, serverless production deployments.

1. Create a free account at [neon.tech](https://neon.tech)
2. Create a new project and copy the connection string
3. Uncomment these lines in `.env.local`:

```env
STORAGE_TYPE=postgres
DATABASE_URL=postgresql://username:password@host/database?sslmode=require
```

**Features:**
- Serverless PostgreSQL optimized for edge computing
- Generous free tier (512MB storage, 3GiB data transfer/month)
- Automatic scaling and connection pooling
- Built-in branching for development/staging
- Compatible with Vercel, Netlify, and other platforms

### Option B: SQLite (Recommended for Development)

Uncomment these lines in `.env.local`:

```env
STORAGE_TYPE=sqlite
DATA_DIR=./data
```

That's it! SQLite requires no additional setup. The database will be created automatically at `./data/cms.db`.

### Option C: JSON File Storage (Simplest Setup)

Uncomment these lines in `.env.local`:

```env
STORAGE_TYPE=json
DATA_DIR=./data
```

Perfect for quick prototyping. Data is stored in `./data/cms-data.json`.

### Option D: Firebase (Alternative for Production)

1. Create a Firebase project at https://console.firebase.google.com
2. Enable Firestore Database and Firebase Storage
3. Get your Firebase configuration
4. Uncomment the Firebase section in `.env.local` and add your credentials:

```env
STORAGE_TYPE=firebase
NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_project_id.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_project_id.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_sender_id
NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id
```

4. **Run the development server**

```bash
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) to see your site.

## Usage

### Admin Panel

Access the admin panel at `/admin` to:

- Create and manage pages
- Add sections to pages
- Add and edit content blocks
- Upload images
- Publish/unpublish pages

### Creating a Page

1. Go to `/admin`
2. Click "New Page"
3. Fill in the page details (title, slug, description)
4. Click "Create Page"
5. Add sections and blocks to build your content

### Image Optimization

FireCMS includes advanced image optimization:

**Client-Side:**
- Automatic compression before upload (reduces file size by up to 70%)
- Real-time compression feedback
- File type validation

**Server-Side:**
- Multiple size generation (thumbnail, medium, large, original)
- Auto-rotation based on EXIF data
- Progressive JPEG encoding
- Optimized quality settings

**Delivery:**
- Next.js Image component for automatic optimization
- Responsive images with proper srcset
- Lazy loading for better performance
- Priority loading for above-the-fold images

See [IMAGE_OPTIMIZATION.md](./IMAGE_OPTIMIZATION.md) for detailed documentation.

### Storage Options

FireCMS features a **pluggable storage adapter system** that lets you choose the best backend for your needs:

#### PostgreSQL (Neon) Storage

Perfect for:
- Production deployments
- Serverless/edge applications
- Scalable applications (startups to enterprise)
- Teams needing database branching
- Cost-effective cloud hosting

**Setup:**

1. Sign up at [neon.tech](https://neon.tech) (free tier available)
2. Create a new project
3. Copy your connection string from the dashboard

```env
STORAGE_TYPE=postgres
DATABASE_URL=postgresql://user:pass@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require
```

**Features:**
- Serverless PostgreSQL with auto-scaling
- 512MB storage free tier
- Connection pooling built-in
- Database branching (separate dev/staging/prod)
- Sub-10ms query latency
- Compatible with Vercel, Netlify, Railway
- Full PostgreSQL feature set (JSONB, GIN indexes, CTEs)
- Automatic backups and point-in-time recovery

**Backup:**

```bash
# Neon provides automatic daily backups
# Manual backup via pg_dump
pg_dump $DATABASE_URL > backup-$(date +%Y%m%d).sql

# Or use Neon's branching feature for instant backups
# Create a branch in the Neon dashboard
```

**Deployment Tips:**
- Use Neon's connection pooling for serverless environments
- Enable branch protection for production database
- Use separate Neon projects for staging/production
- Monitor usage in Neon dashboard

#### SQLite Storage

Perfect for:
- Development environments
- Small to medium sites
- Self-hosted deployments
- Offline-first applications

**Setup:**

```env
STORAGE_TYPE=sqlite
DATA_DIR=./data
```

**Features:**
- Zero configuration required
- Fast local queries (< 1ms for most operations)
- Full ACID compliance
- Foreign key constraints and cascading deletes
- Automatic schema creation and migrations
- Version tracking with auto-increment
- Database file location: `./data/cms.db`

**Backup:**

```bash
# Simple file copy
cp ./data/cms.db ./backups/cms-$(date +%Y%m%d).db

# Or use SQLite backup command
sqlite3 ./data/cms.db ".backup './backups/cms.db'"
```

#### JSON File Storage

Perfect for:
- Quick prototyping
- Git-based workflows (track your data!)
- Simple deployments
- Portable data

**Setup:**

```env
STORAGE_TYPE=json
DATA_DIR=./data
```

**Features:**
- Human-readable data format
- Can be version controlled with Git
- Easy data inspection and editing
- Automatic directory creation
- In-memory caching for performance
- Data file location: `./data/cms-data.json`

**Backup:**

```bash
# Simple file copy
cp ./data/cms-data.json ./backups/cms-data-$(date +%Y%m%d).json

# Or commit to Git
git add ./data/cms-data.json
git commit -m "Backup CMS data"
```

**Note:** JSON storage is not recommended for concurrent writes or high-traffic production sites.

#### Firebase Storage

Perfect for:
- Production deployments
- Scalable applications
- Real-time capabilities
- Multi-region hosting

**Setup:**

Requires Firebase project configuration (see installation steps above).

**Features:**
- Unlimited scalability
- Real-time synchronization
- Multi-region replication
- Built-in security rules
- Automatic backups
- CDN-level performance

**Backup:**

Use Firebase's built-in export feature:

```bash
gcloud firestore export gs://[BUCKET_NAME]/[EXPORT_FOLDER]
```

#### Comparison Table

| Feature | PostgreSQL (Neon) | SQLite | JSON | Firebase |
|---------|-------------------|--------|------|----------|
| **Setup Time** | ~3 min | < 1 min | < 1 min | ~10 min |
| **Read Speed** | Very Fast | Very Fast | Very Fast | Fast |
| **Write Speed** | Very Fast | Very Fast | Fast | Medium |
| **Concurrent Writes** | Excellent | Good | Poor | Excellent |
| **Max Data Size** | Unlimited | ~281 TB | ~2 GB | Unlimited |
| **Hosting Cost** | Free tier (512MB) | Free | Free | Pay-per-use |
| **Scaling** | Auto-scale | Manual | N/A | Auto-scale |
| **Backup** | Automatic | File copy | File copy | Cloud export |
| **Edge Support** | Excellent | N/A | N/A | Good |
| **Best For** | Production | Development | Prototyping | Enterprise |

#### Switching Storage Backends

You can migrate between storage types:

1. Export your data from the current backend
2. Change `STORAGE_TYPE` in `.env.local`
3. Import data to the new backend

For detailed migration instructions, see [STORAGE.md](./STORAGE.md).

#### Performance Tips

**PostgreSQL (Neon):**
- Use connection pooling for serverless environments (enabled by default)
- Enable query caching for frequently accessed pages
- Use database branching to test optimizations safely
- Monitor slow queries in Neon dashboard
- Consider read replicas for high-traffic applications

**SQLite:**
- Database file is automatically indexed for fast queries
- Use `PRAGMA optimize` periodically for best performance
- Consider WAL mode for concurrent reads: `PRAGMA journal_mode=WAL;`
- Vacuum database occasionally: `sqlite3 ./data/cms.db "VACUUM;"`

**JSON:**
- All data is loaded into memory on startup
- Write operations are synchronous and block
- Keep total data under 100MB for best performance
- Not suitable for high-traffic production sites

**Firebase:**
- Optimize Firestore indexes for your queries
- Use pagination for large result sets
- Consider caching frequently accessed data
- Monitor quota usage in Firebase Console

### API Endpoints

#### Pages

- `GET /api/pages` - List all pages
- `POST /api/pages` - Create a new page
- `GET /api/pages/[id]` - Get a specific page
- `PUT /api/pages/[id]` - Update a page
- `DELETE /api/pages/[id]` - Delete a page

#### Sections

- `POST /api/pages/[id]/sections` - Create a section
- `PUT /api/pages/[id]/sections/[sectionId]` - Update a section
- `DELETE /api/pages/[id]/sections/[sectionId]` - Delete a section

#### Blocks

- `POST /api/pages/[id]/sections/[sectionId]/blocks` - Create a block
- `PUT /api/pages/[id]/sections/[sectionId]/blocks/[blockId]` - Update a block
- `DELETE /api/pages/[id]/sections/[sectionId]/blocks/[blockId]` - Delete a block

#### Upload

- `POST /api/upload` - Upload an image (multipart/form-data with 'file' field)

### Example API Usage

**Create a page:**

```javascript
const response = await fetch('/api/pages', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    slug: 'my-page',
    title: 'My Page',
    description: 'A great page',
    published: true
  })
});
const page = await response.json();
```

**Add a text block:**

```javascript
await fetch(`/api/pages/${pageId}/sections/${sectionId}/blocks`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    type: 'text',
    content: 'Hello, world!'
  })
});
```

## Development

### Tech Stack

- **Framework**: Next.js 16 with App Router
- **Language**: TypeScript 5.9
- **Database**: Pluggable adapters (PostgreSQL/Neon, Firebase Firestore, SQLite, JSON)
- **Storage**: @neondatabase/serverless (PostgreSQL), Firebase Storage (images), better-sqlite3 (SQLite), fs (JSON)
- **Styling**: Tailwind CSS 4.1
- **UI Components**: shadcn/ui
- **Package Manager**: pnpm

### Scripts

- `pnpm dev` - Start development server
- `pnpm build` - Build for production
- `pnpm start` - Start production server
- `pnpm lint` - Run ESLint

## Deployment

### Vercel (Recommended)

1. Push your code to GitHub
2. Import the project in Vercel
3. Add environment variables
4. Deploy

### Firebase Hosting

```bash
pnpm build
firebase deploy
```

## License

MIT License - see LICENSE file for details

## Author

Sabeur Thabti

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## Troubleshooting

### Storage Issues

**SQLite: "Database is locked" error**
```bash
# Check for stale processes
lsof ./data/cms.db

# Or restart the dev server
```

**JSON: Data not persisting**
```bash
# Ensure DATA_DIR exists and is writable
ls -la ./data/
chmod 755 ./data/
```

**Firebase: Connection errors**
```bash
# Verify environment variables are set
echo $NEXT_PUBLIC_FIREBASE_PROJECT_ID

# Check Firebase project status at console.firebase.google.com
```

**Switching storage backends**
```bash
# Your data won't automatically migrate!
# Export data first, then change STORAGE_TYPE, then import
# See STORAGE.md for migration guide
```

### Common Issues

**Port already in use**
```bash
# Kill process on port 3000
lsof -ti:3000 | xargs kill -9

# Or use a different port
pnpm dev -- -p 3001
```

**Module not found errors**
```bash
# Clear cache and reinstall
rm -rf node_modules .next
pnpm install
```

## Support

For issues and questions, please use the GitHub issue tracker.
